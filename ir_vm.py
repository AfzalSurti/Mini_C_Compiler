# we create a virtual machine to execute the IR code generated by the IRGenerator. The virtual machine will have a simple instruction set and a memory model to store variables and temporary values.

class IRVM:
    def __init__(self):
        self.env={}

    def default_value(self,var_type):
        if var_type in ("float","double"):
            return 0.0
        if var_type=="string":
            return ""
        return 0

    def resolve(self,x):
        """
        x can be:
        - int (literal)
        - str like "a" or "t1" (variable/temp name)
        """

        if isinstance(x,(int,float)):
            return x

        if isinstance(x,tuple) and len(x)==2 and x[0]=="STR":
            return x[1]
        
        if isinstance(x,str):
            if x not in self.env:
                raise Exception(f"Runtime error : '{x}' has no value")
            return self.env[x]
        
        raise Exception(f"runtime error: unsupported value type {type(x)}")
    

    def run(self,instructions):
        for inst in instructions:
            op=inst[0]

            if op=="DECL_ARRAY":
                _,name,var_type,size=inst
                self.env[name]=[self.default_value(var_type) for _ in range(size)]
                continue

            if op=="STORE":
                _, name ,value=inst # unpacking the tuple 
                if isinstance(self.env.get(name),list):
                    raise Exception(f"Runtime error : '{name}' is an array; use indexing")
                self.env[name]=self.resolve(value) # the resolve method is used to get the value of the variable or temporary variable. It checks if the value is an integer literal or a string representing a variable name. If it is an integer literal, it returns the integer value. If it is a string, it looks up the value in the environment dictionary (self.env) and returns it. If the variable name is not found in the environment, it raises a runtime error.
                
            elif op=="BINOP":
                _,temp,operator,left,right=inst
                l=self.resolve(left)
                r=self.resolve(right)

                if operator=="+":
                    self.env[temp]=l+r

                elif operator=="-":
                    self.env[temp]=l-r

                elif operator=="*":
                    self.env[temp]=l*r

                elif operator=="/":
                    if isinstance(l,float) or isinstance(r,float):
                        self.env[temp]=l/r
                    else:
                        self.env[temp]=l//r

                else:
                    raise Exception(f"runtime error: unknown error {operator}")
                

            elif op=="PRINT":
                _,value=inst
                print(self.resolve(value))

            elif op=="LOAD_INDEX":
                _,temp,name,index_val=inst
                idx=self.resolve(index_val)
                if not isinstance(idx,int):
                    raise Exception("Runtime error : array index must be int")
                arr=self.env.get(name)
                if not isinstance(arr,list):
                    raise Exception(f"Runtime error : '{name}' is not an array")
                if idx<0 or idx>=len(arr):
                    raise Exception(f"Runtime error : array index out of bounds")
                self.env[temp]=arr[idx]

            elif op=="STORE_INDEX":
                _,name,index_val,value_val=inst
                idx=self.resolve(index_val)
                if not isinstance(idx,int):
                    raise Exception("Runtime error : array index must be int")
                arr=self.env.get(name)
                if not isinstance(arr,list):
                    raise Exception(f"Runtime error : '{name}' is not an array")
                if idx<0 or idx>=len(arr):
                    raise Exception(f"Runtime error : array index out of bounds")
                arr[idx]=self.resolve(value_val)

            else:
                raise Exception(f"runtime error: unknown instruction {op}")
