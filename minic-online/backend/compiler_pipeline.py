import os,tempfile,subprocess,textwrap # for temporary file handling and subprocess execution
import re
import sys
from pathlib import Path
from typing import Dict , Any, List, Tuple # for type annotations

PROJECT_ROOT = Path(__file__).resolve().parents[2]
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

from lexer import tokenize # for lexical analysis
from parser import Parser # for parsing the tokens into an abstract syntax tree (AST)
from semantic import SemanticAnalyzer # for semantic analysis of the AST
from ir_generation import IRGenerator # for generating intermediate representation (IR) from the AST
from optimizer import Optimizer # for optimizing the IR
from llvm_codegen import LLVMCodeGen
from ir_vm import   IRVM


def _offset_to_line_col(source: str, offset: int) -> Tuple[int, int]:
    if offset < 0:
        offset = 0
    if offset > len(source):
        offset = len(source)

    line = source.count("\n", 0, offset) + 1
    last_newline = source.rfind("\n", 0, offset)
    column = offset + 1 if last_newline == -1 else (offset - last_newline)
    return line, column


def _format_error_with_source(source: str, message: str) -> str:
    match = re.search(r"(?:position|pos)\s*(\d+)", message)
    if not match:
        return message

    offset = int(match.group(1))
    line, column = _offset_to_line_col(source, offset)
    lines = source.splitlines()
    source_line = lines[line - 1] if 1 <= line <= len(lines) else ""
    caret_line = (" " * max(column - 1, 0)) + "^"

    return f"{message}\nAt line {line}, column {column}\n{source_line}\n{caret_line}"

def run_pipeline(code: str,mode:str="irvm")->Dict[str,Any]:
    """
    mode:
        -"irvm": run the IR code on the IR virtual machine
        -"native": generate native code using LLVM and execute it

    """
    result:Dict[str,Any]={
        "ok":False,
        "phase":"",
        "stdout":"",
        "stderr":"",
        "tokens":[],
        "ast":None,
        "ir":[],
        "optimized_ir":[],
        "llvm":"",
    }

    try:
        # Lexical analysis
        result["phase"]="lexer"
        tokens=tokenize(code)
        result["tokens"]=[f"{t.type}({t.value})@{t.pos}" for t in tokens] # this line is used to create a list of strings that represent the tokens in a readable format. Each token is represented as a string in the format "type(value)@position", where type is the type of the token, value is the value of the token, and position is the position of the token in the source code. This allows for easy debugging and visualization of the tokens generated by the lexer.

        #parser
        result["phase"]="parser"
        ast=Parser(tokens).parse()
        result["ast"]=str(ast) # this line is used to convert the abstract syntax tree (AST) into a string representation and store it in the result dictionary under the key "ast". This allows for easy visualization and debugging of the AST generated by the parser.


        #semantic analysis
        result["phase"]="semantic"
        analyzer=SemanticAnalyzer()
        for stmt in ast:
            analyzer.visit(stmt)

        if mode=="native":
            for name,info in analyzer.symbol_table.items():
                if info["is_array"] or info["type"] != "int":
                    result["stderr"]=f"Native mode supports only int scalars. '{name}' is {info['type']}"
                    result["phase"]="native_not_supported"
                    return result

            if any(t in ("float","double","string") for t in analyzer.used_types):
                result["stderr"]="Native mode supports only int expressions."
                result["phase"]="native_not_supported"
                return result

        #IR generation
        result["phase"]="ir"
        ir=IRGenerator().generate(ast)
        result["ir"]=ir # this line is used to store the generated intermediate representation (IR) in the result dictionary under the key "ir". This allows for easy visualization and debugging of the IR generated from the AST.

        #IR optimization
        result["phase"]="optimize"
        optimized=Optimizer().optimize(ir)
        result["optimized_ir"]=optimized # this line is used to store the optimized intermediate representation (IR) in the result dictionary under the key "optimized_ir". This allows for easy visualization and debugging of the optimized IR generated from the original IR.

        #Execute

        if mode=="irvm":
            result["phase"]="irvm"
            import io,sys # for capturing the standard output and error streams

            buf=io.StringIO() # this line is used to create a new StringIO object called buf, which is an in-memory file-like object that can be used to capture the output of the IR virtual machine (IRVM) when it runs the optimized IR code. By redirecting the standard output to this buffer, we can later retrieve the output generated by the IRVM and store it in the result dictionary under the key "stdout" for further analysis or display.
            old_stdout=sys.stdout # this line is used to save the current standard output stream (sys.stdout) to a variable called old_stdout. This is done so that we can restore the original standard output stream after we have redirected it to the StringIO buffer (buf) to capture the output of the IR virtual machine (IRVM). By saving the original standard output stream, we can ensure that any subsequent print statements or output generated by the program will be directed to the correct destination after we are done capturing the IRVM output.
            sys.stdout=buf# this line is used to redirect the standard output stream (sys.stdout) to the StringIO buffer (buf) that we created earlier. This allows us to capture any output generated by the IR virtual machine (IRVM) when it runs the optimized IR code. By redirecting sys.stdout to buf, we can later retrieve the captured output from the buffer and store it in the result dictionary under the key "stdout" for further analysis or display.

            try:
                IRVM().run(optimized)
            finally:
                sys.stdout=old_stdout

            result["stdout"]=buf.getvalue()
             # this line is used to retrieve the captured output from the StringIO buffer (buf) and store it in the result dictionary under the key "stdout". The getvalue() method of the StringIO object is called to get the entire contents of the buffer as a string, which represents the output generated by the IR virtual machine (IRVM) when it ran the optimized IR code. This allows us to analyze or display the output generated by the IRVM after executing the optimized IR code.
            result["ok"]=True
            return result
        

        if mode=="native":
            result["phase"]="llvm_codegen"
            llvm=LLVMCodeGen().generate(optimized)
            result["llvm"]=llvm # this line is used to store the generated LLVM IR code in the result dictionary under the key "llvm". This allows for easy visualization and debugging of the LLVM IR code generated from the optimized intermediate representation (IR).

            with tempfile.TemporaryDirectory() as td:
                ll_path=os.path.join(td,"out.ll")
                exe_path=os.path.join(td,"program")

                with open(ll_path,"w",encoding="utf-8") as f:
                    f.write(llvm)

                result["phase"]="clang_compile"

                compile_cmd=["clang",ll_path,"-O0","-o",exe_path ] # this line is used to define the command for compiling the generated LLVM IR code into a native executable using the Clang compiler. The command is represented as a list of strings, where "clang" is the name of the compiler, ll_path is the path to the LLVM IR file that we want to compile, "-O0" is an optimization flag that tells the compiler not to perform any optimizations during compilation, and "-o" followed by exe_path specifies the output path for the compiled executable. This command will be executed later using subprocess.run() to compile the LLVM IR code into a native executable that can be run on the target platform.
                cp=subprocess.run( # 
                    compile_cmd, 
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if cp.returncode!=0:
                    result["stderr"]=cp.stderr[:5000]
                    result["phase"]="clang_error"
                    return result
                
                result["phase"]="native_run"

                rp=subprocess.run( # 
                    [exe_path], 
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                result["stdout"]=(rp.stdout or "")[:5000]
                result["stderr"]=(rp.stderr or "")[:5000]
                result["ok"]=(rp.returncode==0)

                return result
            
        result["stderr"]=f"Unknown mode: {mode}"
        result["phase"]="bad_request"
        return result
    

    except Exception as e:
        result["stderr"]=_format_error_with_source(code, str(e))
        result["phase"]=f"error_in_{result['phase']}"
        return result
    

    